//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.18331
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

public sealed class TileManager
{
    private TileManager ()
    {
    }

    private static List<Player> m_players = new List<Player>();
    private static Dictionary<TileType, List<TriggerInstance>> m_subscribers = new Dictionary<TileType, List<TriggerInstance>> ();

    public static List<TileInstance> GetAdjacent (TileInstance p_tile)
    {
        return p_tile.GetAdjacentInstances();
    }

    public static List<TileInstance> GetAllTiles ()
    {
        List<TileInstance> tiles = new List<TileInstance>();
        foreach (Player player in m_players) {
            tiles.AddRange(player.tiles);
        }

        return tiles;
    }

    public static List<TileInstance> GetTilesOfPlayer (Player p_player)
    {
        if (Manages(p_player))
            return p_player.tiles;
        return null;
    }

    public static List<TileInstance> GetTilesOfOtherPlayers (Player p_player)
    {
        List<TileInstance> tiles = new List<TileInstance>();
        foreach (Player player in m_players) {
            if (player != p_player)
                tiles.AddRange(player.tiles);
        }

        return tiles;
    }

    public static List<TileInstance> GetAdjacentToOwnLake (Player p_player)
    {
        // TODO
        return null;
    }

    public static void HandleNewTileImmediateEffect (TileInstance p_new_tile)
    {
        p_new_tile.ApplyImmediateEffect ();
    }

    public static void HandleNewTileConditionalEffect (TileInstance p_new_tile)
    {
        // Apply all the triggers of the new tile :

        foreach (TriggerInstance trigger in p_new_tile.triggers) {
            if (trigger.trigger.when == ETileWhen.AFTER_RED_LINE || trigger.trigger.when == ETileWhen.AFTER) {
                continue;
            }

            List<TileInstance> tile_instances = null;

            switch (trigger.trigger.scope) {
            case ETileScope.ADJACENT:

                tile_instances = GetAdjacent (p_new_tile);
                break;

            case ETileScope.OWN:

                tile_instances = GetTilesOfPlayer (p_new_tile.owner);
                break;

            case ETileScope.GLOBAL:

                tile_instances = GetAllTiles();
                break;

            case ETileScope.OTHER:

                tile_instances = GetTilesOfOtherPlayers (p_new_tile.owner);
                break;

            case ETileScope.ADJACENT_TO_OWN_LAKE:

                tile_instances = GetAdjacentToOwnLake (p_new_tile.owner);
                break;

            case ETileScope.NONE:

                Debug.LogError ("Bug found ! No tile here with a when always and a scope equal to none...");
                continue;
            }

            if (tile_instances == null) {
                Debug.LogWarning ("Tile instances empty !");
                continue;
            }

            TileType trigger_on_tile_type = trigger.trigger.type;
            int number_of_tiles = 0;

            foreach (TileInstance other in tile_instances) {
                if (other.IsOfType (trigger_on_tile_type))
                    number_of_tiles += 1;
            }

            trigger.trigger.effect.Apply (p_new_tile.owner, number_of_tiles);
        }
    }

    public static void EmitNewTileEvent (TileInstance p_new_tile)
    {

        foreach (TileType type in p_new_tile.types) {

            List<TriggerInstance> subscribed_triggers;
            m_subscribers.TryGetValue (type, out subscribed_triggers);

            subscribed_triggers.Sort (
                            (p_trigger1, p_trigger2) =>
            // On serre très fort les fesses.
                            - p_trigger1.owner.IsAdjacentTo (p_new_tile).CompareTo (p_trigger2.owner.IsAdjacentTo (p_new_tile))
            );

            foreach (TriggerInstance trigger in subscribed_triggers) {
                trigger.Apply (p_new_tile);
            }
        }
    }

    public static void AddSubscriber (TriggerInstance p_trigger)
    {
        TileType type_trigger = p_trigger.trigger.type;
        List<TriggerInstance> list;
        if (!m_subscribers.ContainsKey (type_trigger)) {

            list = new List<TriggerInstance> ();
            list.Add (p_trigger);

            m_subscribers.Add (type_trigger, list);

        } else {
            m_subscribers.TryGetValue (type_trigger, out list);
            list.Add (p_trigger);
        }
    }

    public static void AddPlayer(Player p_player)
    {
        m_players.Add(p_player);
    }

    public static void RemovePlayer (Player p_player)
    {
        m_players.Remove(p_player);
    }

    public static bool Manages(Player p_player)
    {
        return m_players.Contains(p_player);
    }
}


